<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Resgate Estelar - A Jornada dos Chefes</title>
    <link rel="icon" type="image/png" href="../../assets/faviconNick.ico">
    <link rel="stylesheet" href="../../styles.css">
    <link
        href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Montserrat:wght@400;600&display=swap"
        rel="stylesheet">
    <style>
        :root {
            --cor-romantica-primaria: #ff4d6d;
            --cor-romantica-secundaria: #ffccd5;
            --cor-romantica-terciaria: #c9184a;
            --cor-fundo-noite: #0a0a1a;
            --fonte-romantica: 'Dancing Script', cursive;
            --fonte-texto: 'Montserrat', sans-serif;
            --cor-tiro: #ff8c00;
            --cor-inimigo: #444;
            --cor-boss: #ff0055;
        }

        body,
        html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--cor-fundo-noite);
            font-family: var(--fonte-texto);
            cursor: none;
            touch-action: none;
            user-select: none;
        }

        #gameCanvas {
            display: block;
        }

        .ui-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            width: auto;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            z-index: 50;
        }

        .game-title {
            font-family: var(--fonte-romantica);
            font-size: 3.5rem;
            color: var(--cor-romantica-secundaria);
            text-shadow: 0 0 20px var(--cor-romantica-primaria);
            margin: 0;
        }

        .status-container {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }

        .meter {
            color: white;
            font-size: 1.2rem;
            background: rgba(255, 77, 109, 0.2);
            padding: 8px 20px;
            border-radius: 20px;
            border: 1px solid var(--cor-romantica-primaria);
            backdrop-filter: blur(5px);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .meter.boss-alert {
            border-color: var(--cor-boss);
            color: var(--cor-boss);
            font-weight: bold;
            animation: pulse-red 0.5s infinite alternate;
        }

        @keyframes pulse-red {
            from {
                box-shadow: 0 0 5px var(--cor-boss);
            }

            to {
                box-shadow: 0 0 20px var(--cor-boss);
            }
        }

        #bossHealthContainer {
            position: absolute;
            top: 150px;
            width: 300px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            display: none;
            overflow: hidden;
            border: 1px solid white;
        }

        #bossHealthBar {
            width: 100%;
            height: 100%;
            background: var(--cor-boss);
            transition: width 0.3s ease;
        }

        .victory-screen {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            background: rgba(255, 255, 255, 0.95);
            padding: 3em;
            border-radius: 30px;
            box-shadow: 0 0 50px rgba(255, 77, 109, 0.8);
            border: 4px solid var(--cor-romantica-primaria);
            text-align: center;
            z-index: 100;
            opacity: 0;
            display: none;
            transition: all 0.5s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 500px;
            pointer-events: auto;
        }

        .victory-screen.show {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            display: block;
        }

        .victory-title {
            font-family: var(--fonte-romantica);
            font-size: 4rem;
            color: var(--cor-romantica-terciaria);
            margin-bottom: 0.5em;
        }

        .love-button {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            padding: 1em 2em;
            background-color: var(--cor-romantica-primaria);
            color: white;
            border-radius: 50px;
            font-family: var(--fonte-romantica);
            font-size: 1.2rem;
            transition: all 0.3s ease;
            border: none;
            cursor: pointer;
            text-decoration: none;
        }

        .love-button:hover {
            transform: scale(1.1);
            background-color: var(--cor-romantica-terciaria);
        }

        #instructionHint {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 30px;
            font-size: 1rem;
            z-index: 5;
            pointer-events: none;
        }

        .shake {
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% {
                transform: translate(1px, 1px) rotate(0deg);
            }

            10% {
                transform: translate(-1px, -2px) rotate(-1deg);
            }

            20% {
                transform: translate(-3px, 0px) rotate(1deg);
            }

            30% {
                transform: translate(3px, 2px) rotate(0deg);
            }

            40% {
                transform: translate(1px, -1px) rotate(1deg);
            }

            50% {
                transform: translate(-1px, 2px) rotate(-1deg);
            }

            60% {
                transform: translate(-3px, 1px) rotate(0deg);
            }

            70% {
                transform: translate(3px, 1px) rotate(-1deg);
            }

            80% {
                transform: translate(-1px, -1px) rotate(1deg);
            }

            90% {
                transform: translate(1px, 2px) rotate(0deg);
            }

            100% {
                transform: translate(1px, -2px) rotate(-1deg);
            }
        }

        .game-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 15px;
            z-index: 100;
        }

        .control-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: rgba(255, 77, 109, 0.3);
            border: 2px solid var(--cor-romantica-primaria);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            cursor: pointer;
            backdrop-filter: blur(5px);
            transition: all 0.3s ease;
            pointer-events: auto;
        }

        .control-btn:hover {
            background: var(--cor-romantica-primaria);
            transform: scale(1.1);
        }

        #pauseOverlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 50;
            pointer-events: none;
        }

        .pause-text {
            font-family: var(--fonte-romantica);
            font-size: 5rem;
            color: white;
            text-shadow: 0 0 20px var(--cor-romantica-primaria);
        }

        #mobileShootBtn {
            position: fixed;
            bottom: 40px;
            right: 40px;
            width: 100px;
            height: 100px;
            border-radius: 50%;
            background: rgba(255, 77, 109, 0.4);
            border: 4px solid var(--cor-romantica-primaria);
            color: white;
            display: none;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            z-index: 100;
            pointer-events: auto;
            backdrop-filter: blur(5px);
            font-family: var(--fonte-texto);
            font-weight: bold;
            -webkit-tap-highlight-color: transparent;
        }

        #mobileShootBtn:active {
            transform: scale(0.9);
            background: var(--cor-romantica-primaria);
        }

        .life-container {
            display: flex;
            gap: 8px;
            margin-bottom: 10px;
        }

        .heart-icon {
            color: var(--cor-romantica-primaria);
            font-size: 2.2rem;
            filter: drop-shadow(0 0 5px rgba(0, 0, 0, 0.5));
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .heart-icon.lost {
            color: rgba(255, 255, 255, 0.2);
            transform: scale(0.8);
            filter: none;
        }
    </style>
</head>

<body class="romantic-mode no-cursor-fx">
    <div class="custom-cursor">
        <div class="inner-cursor"></div>
        <div class="outer-cursor"></div>
    </div>
    <div class="stars-container" id="stars"></div>


    <div class="ui-overlay">
        <div class="life-container" id="lifeContainer">
            <ion-icon name="heart" class="heart-icon"></ion-icon>
            <ion-icon name="heart" class="heart-icon"></ion-icon>
            <ion-icon name="heart" class="heart-icon"></ion-icon>
            <ion-icon name="heart" class="heart-icon"></ion-icon>
            <ion-icon name="heart" class="heart-icon"></ion-icon>
        </div>
        <div class="status-container">
            <div class="meter" id="distanceText">Distância: 5000m</div>
        </div>
        <div id="bossHealthContainer">
            <div id="bossHealthBar"></div>
        </div>
    </div>

    <div class="game-controls">
        <button class="control-btn" id="pauseBtn" title="Pausar">
            <ion-icon name="pause"></ion-icon>
        </button>
    </div>

    <div id="pauseOverlay">
        <div style="display: flex; flex-direction: column; align-items: center; gap: 20px;">
            <div class="pause-text" style="margin-bottom: 10px;">Pausado</div>

            <button class="love-button" onclick="togglePause()" style="width: 250px; justify-content: center;">
                <ion-icon name="play-outline"></ion-icon>
                Continuar
            </button>

            <button class="love-button" id="autoFireBtn"
                style="width: 250px; justify-content: center; background: rgba(0,0,0,0.4); border: 2px solid var(--cor-romantica-secundaria);">
                <ion-icon name="flash-outline"></ion-icon>
                Auto-Fire: OFF
            </button>

            <button class="love-button" id="muteBtnOverlay"
                style="width: 250px; justify-content: center; background: rgba(0,0,0,0.4); border: 2px solid var(--cor-romantica-secundaria);">
                <ion-icon name="volume-high-outline"></ion-icon>
                Som: ON
            </button>

            <a href="selecao-fases.html" class="love-button"
                style="width: 250px; justify-content: center; background: var(--cor-romantica-terciaria); text-decoration: none;">
                <ion-icon name="arrow-back-outline"></ion-icon>
                Voltar ao Menu
            </a>
        </div>
    </div>

    <button id="mobileShootBtn">FOGO!</button>

    <div id="instructionHint">Atire para se defender e cavalgue rumo ao amor!</div>
    <canvas id="gameCanvas"></canvas>

    <div class="victory-screen" id="victoryScreen">
        <h2 class="victory-title">Missão Cumprida!</h2>
        <p style="font-size: 1.3rem; line-height: 1.6; color: #4a4a4a; margin-bottom: 2em;">
            Você derrotou todos os obstáculos e provou que nosso amor é invencível. <br>
            <strong>Ashley, você é meu destino final!</strong> ❤️
        </p>
        <div style="display: flex; gap: 15px; justify-content: center;">
            <button class="love-button" onclick="location.reload()">Voar de Novo</button>
            <a href="selecao-fases.html" class="love-button"
                style="background: var(--cor-romantica-terciaria);">Continuar</a>
        </div>
    </div>

    <!-- Game Over Screen -->
    <div class="victory-screen" id="gameOverScreen" style="border-color: #555; box-shadow: 0 0 50px rgba(0,0,0,0.5);">
        <h2 class="victory-title" style="color: #333;">Voo Interrompido</h2>
        <p style="font-size: 1.3rem; line-height: 1.6; color: #4a4a4a; margin-bottom: 2em;">
            O Banguela precisou pousar para descansar. <br>
            <strong>Mas nosso amor nunca cansa!</strong> ❤️
        </p>
        <div style="display: flex; gap: 15px; justify-content: center;">
            <button class="love-button" onclick="location.reload()">Tentar de Novo</button>
            <a href="selecao-fases.html" class="love-button" style="background: #555;">Voltar</a>
        </div>
    </div>

    <audio id="bgMusic"></audio>

    <script src="../../app.js" defer></script>
    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const bossHealthBar = document.getElementById('bossHealthBar');
        const bossHealthContainer = document.getElementById('bossHealthContainer');
        const distanceText = document.getElementById('distanceText');

        let gameActive = true;
        let isPaused = false;
        let distance = 10000;
        let targetX = window.innerWidth / 2;
        let frameCount = 0;

        const player = { x: window.innerWidth / 2, y: window.innerHeight - 200, width: 180, height: 180, shakes: 0, currentFrame: 1, frameTimer: 0, isAttacking: 0, hp: 5, invincibility: 0 };

        // Shooting Control
        let isShooting = false;
        let shootTimer = 0;
        const shootCooldown = 25; // Reverted to 25 from 45
        let autoFire = localStorage.getItem('autoFire') === 'true';
        const goal = { x: 0, y: -200, width: 180, height: 180, show: false, following: false, victoryTimer: 0, currentFrame: 1, frameTimer: 0 };
        const cage = { hp: 10, broken: false };

        const bullets = [];
        const enemyBullets = [];
        const enemies = [];
        const boss = { active: false, x: 0, y: -200, hp: 0, maxHp: 0, phase: 0, shootTimer: 0 };
        const obstacles = [];
        const stars = [];
        const particles = [];

        // Loading Images
        // Check Character Selection
        const urlParams = new URLSearchParams(window.location.search);
        const selectedCharacter = urlParams.get('character') || 'banguela';

        const isBanguela = selectedCharacter === 'banguela';
        const playerPrefix = isBanguela ? 'NightFury' : 'LightFury';
        const goalPrefix = isBanguela ? 'LightFury' : 'NightFury';
        const bulletColor = isBanguela ? '#ff8c00' : '#d8bfd8';

        // Loading Images
        const playerImages = [];
        for (let i = 1; i <= 5; i++) {
            const img = new Image();
            img.src = `../../assets/gameImages/${playerPrefix}${i}.png`;
            playerImages.push(img);
        }
        const playerAttackImg = new Image();
        playerAttackImg.src = `../../assets/gameImages/${playerPrefix}AttackBasic.png`;

        const goalImages = [];
        for (let i = 1; i <= 5; i++) {
            const img = new Image();
            img.src = `../../assets/gameImages/${goalPrefix}${i}.png`;
            goalImages.push(img);
        }
        const goalAttackImg = new Image();
        goalAttackImg.src = `../../assets/gameImages/${goalPrefix}AttackBasic.png`;

        function initStars() {
            for (let i = 0; i < 150; i++) stars.push({ x: Math.random() * window.innerWidth, y: Math.random() * window.innerHeight, size: Math.random() * 2 + 1, speed: Math.random() * 3 + 2 });
        }

        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; player.y = canvas.height - 200; });
        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        initStars();

        window.addEventListener('mousemove', (e) => {
            if (!isPaused) targetX = e.clientX;
        });

        // Mouse Holding
        window.addEventListener('mousedown', () => { if (gameActive && !isPaused) isShooting = true; });
        window.addEventListener('mouseup', () => { isShooting = false; });

        // Touch Holding
        window.addEventListener('touchstart', (e) => {
            if (gameActive && !isPaused) {
                targetX = e.touches[0].clientX;
                isShooting = true;
            }
        });
        window.addEventListener('touchend', () => { isShooting = false; });

        window.addEventListener('touchmove', (e) => {
            if (gameActive && !isPaused) {
                targetX = e.touches[0].clientX;
                e.preventDefault();
            }
        }, { passive: false });

        // Spacebar Shooting
        window.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && gameActive && !isPaused) isShooting = true;
        });
        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') isShooting = false;
        });

        const pauseBtn = document.getElementById('pauseBtn');
        const muteBtnOverlay = document.getElementById('muteBtnOverlay');
        const autoFireBtn = document.getElementById('autoFireBtn');
        const pauseOverlay = document.getElementById('pauseOverlay');
        const mobileShootBtn = document.getElementById('mobileShootBtn');
        const lifeContainer = document.getElementById('lifeContainer');

        // Initialize Auto-Fire Button
        updateAutoFireBtn();

        // Detecção de mobile
        const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        if (isMobile) {
            mobileShootBtn.style.display = 'flex';
            document.getElementById('instructionHint').textContent = "Arraste para voar e use o botão para atirar!";
        }

        pauseBtn.addEventListener('click', togglePause);
        muteBtnOverlay.addEventListener('click', toggleMute);
        autoFireBtn.addEventListener('click', toggleAutoFire);
        mobileShootBtn.addEventListener('touchstart', (e) => {
            if (gameActive && !isPaused) {
                isShooting = true;
                e.preventDefault();
            }
        });
        mobileShootBtn.addEventListener('touchend', (e) => {
            isShooting = false;
            e.preventDefault();
        });

        function togglePause() {
            isPaused = !isPaused;
            pauseOverlay.style.display = isPaused ? 'flex' : 'none';
            pauseOverlay.style.pointerEvents = isPaused ? 'auto' : 'none'; // Fix clickthrough
            pauseBtn.innerHTML = isPaused ? '<ion-icon name="play"></ion-icon>' : '<ion-icon name="pause"></ion-icon>';
        }

        function toggleMute() {
            const isMuted = bgMusic.muted;
            bgMusic.muted = !isMuted;
            localStorage.setItem('musicMuted', !isMuted);
            updateMuteIcon();
        }

        function updateMuteIcon() {
            const icon = bgMusic.muted ? 'volume-mute-outline' : 'volume-high-outline';
            const text = bgMusic.muted ? 'Som: OFF' : 'Som: ON';
            muteBtnOverlay.innerHTML = `<ion-icon name="${icon}"></ion-icon> ${text}`;
        }

        function toggleAutoFire() {
            autoFire = !autoFire;
            localStorage.setItem('autoFire', autoFire);
            updateAutoFireBtn();
        }

        function updateAutoFireBtn() {
            const icon = autoFire ? 'flash' : 'flash-off-outline';
            const text = autoFire ? 'Auto-Fire: ON' : 'Auto-Fire: OFF';
            const color = autoFire ? 'var(--cor-romantica-primaria)' : 'rgba(0,0,0,0.4)';
            autoFireBtn.innerHTML = `<ion-icon name="${icon}"></ion-icon> ${text}`;
            autoFireBtn.style.background = color;
        }

        // Shooting Logic Check
        function checkShooting() {
            // Auto Fire Logic: Shoot enemies, boss, AND destructible obstacles (nets/mines)
            const destructiblePresent = obstacles.length > 0;
            const enemiesPresent = enemies.length > 0 || boss.active || destructiblePresent;

            const shouldShoot = isShooting || (autoFire && enemiesPresent);

            if (shouldShoot && shootTimer <= 0) {
                shoot();
                shootTimer = shootCooldown;
            }
            if (shootTimer > 0) shootTimer--;
        }

        function shoot() {
            bullets.push({ x: player.x + player.width / 2 - 5, y: player.y + 20, speed: 12, radius: 8, color: bulletColor });
            player.isAttacking = 15; // Mostrar frame de ataque por 15 frames
        }
        function enemyShoot(x, y) {
            const vx = (Math.random() - 0.5) * 4; // Dispersão horizontal
            enemyBullets.push({ x, y, vx, speed: 2.5, radius: 10, color: "red" });
        }

        function createParticles(x, y, color, count = 10) {
            for (let i = 0; i < count; i++) {
                particles.push({
                    x, y,
                    vx: (Math.random() - 0.5) * 5, // Velocidade reduzida pela metade
                    vy: (Math.random() - 0.5) * 5,
                    life: 1.0,
                    color
                });
            }
        }

        function spawnBoss(hp) {
            boss.active = true;
            boss.maxHp = hp;
            boss.hp = hp;
            boss.x = canvas.width / 2 - 100;
            boss.y = -200;
            bossHealthContainer.style.display = 'block';
            distanceText.classList.add('boss-alert');
        }

        function update() {
            if (!gameActive || isPaused) return;
            frameCount++;

            checkShooting();

            if (player.invincibility > 0) player.invincibility--;

            // Player Animation
            player.frameTimer++;
            let playerThreshold = 20; // Base bem mais lenta
            if (player.currentFrame === 1) playerThreshold = 45; // Deixa o frame de "planagem" (asas abertas) por muito mais tempo

            if (player.frameTimer > playerThreshold) {
                player.currentFrame = (player.currentFrame % 5) + 1;
                player.frameTimer = 0;
            }

            if (goal.show) {
                goal.frameTimer++;
                let goalThreshold = 20;
                if (goal.currentFrame === 1) goalThreshold = 45;

                if (goal.frameTimer > goalThreshold) {
                    goal.currentFrame = (goal.currentFrame % 5) + 1;
                    goal.frameTimer = 0;
                }
            }

            // Player control
            player.x += (targetX - player.x) * 0.1;
            if (player.x < 0) player.x = 0;
            if (player.x > canvas.width - player.width) player.x = canvas.width - player.width;

            // Distance & Boss Logic
            if (!boss.active && !goal.show) {
                distance -= 2;
                if (distance <= 5000 && boss.phase === 0) { spawnBoss(10); boss.phase = 1; }
                else if (distance <= 3000 && boss.phase === 1) { spawnBoss(15); boss.phase = 2; }
                else if (distance <= 1000 && boss.phase === 2) { spawnBoss(20); boss.phase = 3; }

                if (frameCount % 300 === 0) { // Inimigos comuns surgem a cada ~5 segundos
                    const margin = 40;
                    enemies.push({ x: margin + Math.random() * (canvas.width - margin * 2 - 60), y: -100, hp: 2, speedY: 1.5, type: 'common' });
                }
                if (frameCount % 500 === 0) { // Inimigo de elite (atira) surge a cada ~8.3 segundos
                    const margin = 60;
                    enemies.push({
                        x: margin + Math.random() * (canvas.width - margin * 2 - 60),
                        y: -100, hp: 3, speedY: 1.2,
                        type: 'elite', shootTimer: 0
                    });
                }

                // Variedade de Obstáculos
                if (frameCount % 350 === 0) { // Redes surgem a cada ~5.8 segundos
                    const margin = 40;
                    obstacles.push({ x: margin + Math.random() * (canvas.width - margin * 2 - 80), y: -100, speedY: 3.5, type: 'net' });
                }
                if (frameCount % 600 === 0) { // Minas surgem a cada ~10 segundos (mais rápidas)
                    const margin = 60;
                    obstacles.push({ x: margin + Math.random() * (canvas.width - margin * 2 - 40), y: -100, speedY: 5, type: 'mine' });
                }
            }
            if (distance <= 0 && !goal.show && !boss.active) {
                goal.show = true; goal.x = canvas.width / 2 - 50; goal.y = -150;
            }
            distanceText.textContent = `Distância: ${Math.max(0, Math.floor(distance))}m`;

            // Stars
            stars.forEach(s => { s.y += s.speed; if (s.y > canvas.height) { s.y = -10; s.x = Math.random() * canvas.width; } });

            // Boss Update
            if (boss.active) {
                if (boss.y < 100) boss.y += 2;
                boss.x += Math.sin(frameCount * 0.05) * 5;
                boss.shootTimer++;
                if (boss.shootTimer > 90) { // Atira menos vezes (intervalo aumentado de 40 para 90)
                    enemyShoot(boss.x + 100, boss.y + 100);
                    boss.shootTimer = 0;
                }
                bossHealthBar.style.width = `${(boss.hp / boss.maxHp) * 100}%`;
            }

            // Bullets (Player)
            for (let i = bullets.length - 1; i >= 0; i--) {
                const b = bullets[i]; b.y -= b.speed;

                // Mini rastro flamejante
                if (frameCount % 2 === 0) {
                    particles.push({
                        x: b.x + (Math.random() - 0.5) * 10,
                        y: b.y + b.radius + Math.random() * 10,
                        vx: (Math.random() - 0.5) * 2,
                        vy: 2 + Math.random() * 2,
                        life: 0.6 + Math.random() * 0.4,
                        color: bulletColor
                    });
                }

                if (boss.active && b.x > boss.x && b.x < boss.x + 200 && b.y > boss.y && b.y < boss.y + 150) {
                    boss.hp--; createParticles(b.x, b.y, "red"); bullets.splice(i, 1);
                    if (boss.hp <= 0) { boss.active = false; bossHealthContainer.style.display = 'none'; distanceText.classList.remove('boss-alert'); createParticles(boss.x + 100, boss.y + 75, "white", 50); }
                    continue;
                }
                if (goal.show && !cage.broken && b.x > goal.x - 20 && b.x < goal.x + 200 && b.y > goal.y - 20 && b.y < goal.y + 200) {
                    cage.hp--; createParticles(b.x, b.y, "#888"); bullets.splice(i, 1);
                    if (cage.hp <= 0) { cage.broken = true; goal.following = true; goal.victoryTimer = 480; }
                    continue;
                }
                enemies.forEach((e, idx) => {
                    if (b.x > e.x && b.x < e.x + 60 && b.y > e.y && b.y < e.y + 60) {
                        e.hp--; createParticles(b.x, b.y, "red", 15); bullets.splice(i, 1);
                        if (e.hp <= 0) {
                            createParticles(e.x + 30, e.y + 30, "#555", 25);
                            enemies.splice(idx, 1);
                        }
                    }
                });

                // Colisão com Obstáculos (a bola de fogo não atravessa)
                obstacles.forEach((o, idx) => {
                    if (b.x > o.x && b.x < o.x + 80 && b.y > o.y && b.y < o.y + 80) {
                        createParticles(b.x, b.y, "#ff8c00", 20); // Efeito de impacto
                        createParticles(o.x + 40, o.y + 40, "#555", 15); // Efeito de destruição do objeto
                        bullets.splice(i, 1);
                        obstacles.splice(idx, 1);
                    }
                });

                if (b.y < -50) bullets.splice(i, 1);
            }

            // Enemy Bullets
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const eb = enemyBullets[i];
                eb.y += eb.speed;
                eb.x += eb.vx || 0; // Aplicar dispersão horizontal

                // Rastro de fumaça sombria e fogo para inimigos
                if (frameCount % 2 === 0) { // Rastro mais denso
                    particles.push({
                        x: eb.x + (Math.random() - 0.5) * 10, y: eb.y - eb.radius,
                        vx: (Math.random() - 0.5) * 1, vy: -1,
                        life: 0.8, color: Math.random() > 0.5 ? "#f00" : "#400"
                    });
                }

                // Colisão com Hitbox reduzida (área central do dragão)
                const hx = player.x + 35, hy = player.y + 35, hw = 110, hh = 110;
                if (eb.x > hx && eb.x < hx + hw && eb.y > hy && eb.y < hy + hh) {
                    takeDamage();
                    enemyBullets.splice(i, 1); continue;
                }
                if (eb.y > canvas.height + 50) enemyBullets.splice(i, 1);
            }

            // Enemies/Obstacles Logic
            enemies.forEach((e, i) => {
                e.y += e.speedY;

                // Lógica de tiro dos inimigos de elite
                if (e.type === 'elite') {
                    e.shootTimer++;
                    if (e.shootTimer > 100) {
                        enemyShoot(e.x + 30, e.y + 60);
                        e.shootTimer = 0;
                    }
                }

                if (e.y > canvas.height + 50) enemies.splice(i, 1);
            });
            obstacles.forEach((o, i) => {
                o.y += o.speedY;
                // Colisão com Hitbox reduzida
                const hx = player.x + 35, hy = player.y + 35, hw = 110, hh = 110;
                if (o.x < hx + hw && o.x + 80 > hx && o.y < hy + hh && o.y + 80 > hy) {
                    takeDamage();
                    createParticles(o.x + 40, o.y + 40, "#ff4d00", 30); // Efeito de explosão na colisão
                    createParticles(o.x + 40, o.y + 40, "white", 10);
                    obstacles.splice(i, 1);
                }
                if (o.y > canvas.height + 50) obstacles.splice(i, 1);
            });

            // Victory state
            if (goal.show) {
                if (!goal.following) { if (goal.y < canvas.height / 4) goal.y += 2; }
                else {
                    const tx = player.x + 90, ty = player.y - 40;
                    goal.x += (tx - goal.x) * 0.08; goal.y += (ty - goal.y) * 0.08;
                    goal.victoryTimer--; if (goal.victoryTimer <= 0) gameWin();
                }
            }

            // Particles (Decaimento mais lento para efeito Slow-mo)
            particles.forEach((p, i) => {
                p.x += p.vx;
                p.y += p.vy;
                p.life -= 0.01; // Decaimento reduzido para durar mais tempo
                if (p.life <= 0) particles.splice(i, 1);
            });
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "white"; stars.forEach(s => { ctx.beginPath(); ctx.arc(s.x, s.y, s.size, 0, Math.PI * 2); ctx.fill(); });
            particles.forEach(p => { ctx.globalAlpha = p.life; ctx.fillStyle = p.color; ctx.beginPath(); ctx.arc(p.x, p.y, 4 * p.life, 0, Math.PI * 2); ctx.fill(); }); ctx.globalAlpha = 1.0;

            // Bullets com efeito Bloom
            ctx.save();
            bullets.forEach(b => {
                ctx.shadowBlur = 25;
                ctx.shadowColor = "#ff4d00";
                ctx.fillStyle = b.color;
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius, 0, Math.PI * 2);
                ctx.fill();

                // Núcleo mais brilhante
                ctx.shadowBlur = 0;
                ctx.fillStyle = "#fff";
                ctx.beginPath();
                ctx.arc(b.x, b.y, b.radius * 0.5, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();

            // Enemy Bullets com efeito Bloom (Fogo Sombrio)
            ctx.save();
            enemyBullets.forEach(eb => {
                // Traço de movimento (Line)
                ctx.strokeStyle = "rgba(255, 0, 0, 0.3)";
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.moveTo(eb.x, eb.y);
                ctx.lineTo(eb.x - (eb.vx || 0) * 5, eb.y - eb.speed * 8);
                ctx.stroke();

                ctx.shadowBlur = 20;
                ctx.shadowColor = "red";
                ctx.fillStyle = "#800";
                ctx.beginPath();
                ctx.arc(eb.x, eb.y, eb.radius, 0, Math.PI * 2);
                ctx.fill();

                // Núcleo pulsante
                ctx.fillStyle = "#f00";
                ctx.beginPath();
                ctx.arc(eb.x, eb.y, eb.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();
            });
            ctx.restore();

            enemies.forEach(e => {
                if (e.type === 'elite') {
                    // Visual Inimigo Elite (Vermelho mais escuro e ameaçador)
                    ctx.fillStyle = "#500";
                    ctx.fillRect(e.x, e.y, 60, 60);
                    ctx.fillStyle = "#f00"; // Detalhes brilhantes
                    ctx.fillRect(e.x + 5, e.y + 10, 50, 5); // Asa superior
                    ctx.fillRect(e.x + 10, e.y + 40, 40, 10); // Parte de baixo
                    ctx.fillStyle = frameCount % 20 < 10 ? "#f00" : "#800"; // Canhão piscante
                    ctx.fillRect(e.x + 25, e.y + 55, 10, 10);
                } else {
                    // Visual Inimigo Comum
                    ctx.fillStyle = "#333";
                    ctx.fillRect(e.x, e.y, 60, 60);
                    ctx.fillStyle = "red";
                    ctx.fillRect(e.x + 10, e.y + 10, 10, 10);
                    ctx.fillRect(e.x + 40, e.y + 10, 10, 10);
                }
            });

            // Obstáculos detalhados
            obstacles.forEach(o => {
                ctx.save();

                if (o.type === 'mine') {
                    // Visual do Meteorito
                    ctx.translate(o.x + 25, o.y + 25);
                    const pulse = Math.sin(frameCount * 0.1) * 3;

                    // Brilho atmosférico/calor
                    ctx.shadowBlur = 20 + pulse;
                    ctx.shadowColor = "#ff6600";
                    ctx.fillStyle = "#4a3c31"; // Marrom rochoso

                    // Desenho irregular do meteorito
                    ctx.beginPath();
                    const points = 7;
                    const radius = 22;
                    for (let i = 0; i < points; i++) {
                        const angle = (i / points) * Math.PI * 2;
                        const dist = radius + (Math.sin(i * 1.5 + frameCount * 0.05) * 4);
                        ctx.lineTo(Math.cos(angle) * dist, Math.sin(angle) * dist);
                    }
                    ctx.closePath();
                    ctx.fill();

                    // Detalhes de Crateras
                    ctx.fillStyle = "#2b231d";
                    const craters = [[-8, -5, 4], [6, 8, 3], [-5, 10, 2]];
                    craters.forEach(c => {
                        ctx.beginPath();
                        ctx.arc(c[0], c[1], c[2], 0, Math.PI * 2);
                        ctx.fill();
                    });

                    // Reflexos de calor nas bordas
                    ctx.shadowBlur = 0;
                    ctx.strokeStyle = "#ff9900";
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(0, 0, 22, 0, Math.PI, false);
                    ctx.stroke();
                } else {
                    // Visual da Rede de Caçadores (padrão)
                    ctx.translate(o.x + 40, o.y + 40);
                    ctx.strokeStyle = "#444";
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    for (let i = 0; i < 8; i++) {
                        ctx.rotate(Math.PI / 4);
                        ctx.moveTo(0, 0); ctx.lineTo(40, 0);
                        ctx.arc(40, 0, 5, 0, Math.PI * 2);
                    }
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(0, 0, 30, 0, Math.PI * 2);
                    ctx.arc(0, 0, 15, 0, Math.PI * 2);
                    ctx.stroke();

                    ctx.fillStyle = frameCount % 30 < 15 ? "#666" : "#f00";
                    ctx.beginPath(); ctx.arc(0, 0, 8, 0, Math.PI * 2); ctx.fill();
                }

                ctx.restore();
            });

            if (boss.active) {
                ctx.fillStyle = "#222"; ctx.shadowBlur = 40; ctx.shadowColor = "red";
                ctx.fillRect(boss.x, boss.y, 200, 150);
                ctx.fillStyle = "red"; ctx.beginPath(); ctx.arc(boss.x + 50, boss.y + 50, 15, 0, Math.PI * 2); ctx.arc(boss.x + 150, boss.y + 50, 15, 0, Math.PI * 2); ctx.fill();
                ctx.shadowBlur = 0;
            }

            if (goal.show) {
                let gImg = goalImages[goal.currentFrame - 1];
                ctx.drawImage(gImg, goal.x, goal.y, goal.width, goal.height);

                if (!cage.broken) {
                    ctx.strokeStyle = "#888";
                    ctx.lineWidth = 4;
                    ctx.strokeRect(goal.x - 10, goal.y - 10, 200, 200);
                    for (let i = 25; i < 200; i += 50) {
                        ctx.beginPath(); ctx.moveTo(goal.x - 10 + i, goal.y - 10); ctx.lineTo(goal.x - 10 + i, goal.y + 190); ctx.stroke();
                    }
                }
            }

            drawPlayer(player.x, player.y);
        }

        function takeDamage() {
            if (player.invincibility > 0) return;
            player.hp--;
            player.invincibility = 120; // 2 segundos
            player.shakes = 20;
            updateHearts();

            document.body.classList.add('shake');
            setTimeout(() => document.body.classList.remove('shake'), 400);

            if (player.hp <= 0) gameOver();
        }

        function updateHearts() {
            const hearts = lifeContainer.querySelectorAll('.heart-icon');
            hearts.forEach((h, i) => {
                if (i >= player.hp) h.classList.add('lost');
                else h.classList.remove('lost');
            });
        }

        function gameOver() {
            gameActive = false;
            document.getElementById('gameOverScreen').classList.add('show');
        }

        function drawPlayer(x, y) {
            ctx.save();
            if (player.invincibility > 0 && frameCount % 10 < 5) ctx.globalAlpha = 0.5;
            if (player.shakes > 0) ctx.translate((Math.random() - 0.5) * 10, (Math.random() - 0.5) * 10);

            let img = playerImages[player.currentFrame - 1];
            if (player.isAttacking > 0) {
                img = playerAttackImg;
                player.isAttacking--;
            }

            ctx.drawImage(img, x, y, player.width, player.height);
            ctx.restore();
        }

        function gameWin() {
            gameActive = false;
            document.getElementById('victoryScreen').classList.add('show');
            localStorage.setItem('fase1Completed', 'true');
            localStorage.setItem('lightFuryUnlocked', 'true');
        }
        function loop() { update(); draw(); requestAnimationFrame(loop); }
        const playlist = [
            "../../assets/gamSongs/test-drive-from-how-to-train-your-dragon-music-from-the-motion-picture-320-ytshorts.savetube.me.mp3",
            "../../assets/gamSongs/Where No One Goes  How to Train Your Dragon 2 (Music from the Motion Picture) - SonySoundtracksVEVO (youtube).mp3"
        ];
        let currentSongIndex = Math.floor(Math.random() * playlist.length);

        function playNextSong() {
            currentSongIndex = (currentSongIndex + 1) % playlist.length;
            bgMusic.src = playlist[currentSongIndex];
            bgMusic.play().catch(() => { });
        }

        bgMusic.onended = playNextSong;
        bgMusic.src = playlist[currentSongIndex];

        document.addEventListener('click', () => { if (bgMusic.paused) bgMusic.play(); }, { once: true });
        loop();
        bgMusic.muted = localStorage.getItem('musicMuted') === 'true';
        updateMuteIcon();
        bgMusic.play().catch(() => { });
    </script>
    <script type="module" src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.esm.js"></script>
    <script nomodule src="https://unpkg.com/ionicons@7.1.0/dist/ionicons/ionicons.js"></script>
</body>

</html>